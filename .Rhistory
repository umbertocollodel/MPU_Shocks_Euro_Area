#detach packages
detachAllPackages <- function() {
basic.packages.blank <-  c("stats",
"graphics",
"grDevices",
"utils",
"datasets",
"methods",
"base")
basic.packages <- paste("package:", basic.packages.blank, sep = "")
package.list <- search()[ifelse(unlist(gregexpr("package:", search())) == 1,
TRUE,
FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list) > 0)  for (package in package.list) {
detach(package, character.only = TRUE)
print(paste("package ", package, " detached", sep = ""))
}
}
detachAllPackages()
#automatically download required packages
check.packages <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg)) {
sapply(new.pkg, install.packages, dependencies = T)
}
sapply(pkg, require, character.only = T)
}
#enter package names
package <- c("relaimpo", "readxl", "tidyverse", "haven", "lubridate", "rJava", "countrycode", "xlsx", "devtools", "shapley")
#load packages (if not installed, they're installed first and then loaded into the environment)
check.packages(package)
#download shapley value decomposition package
#devtools::install_github("elbersb/shapley")
#housekeeping
rm(list = ls())
#set working directory
path <- getwd()
setwd(path)
#some functions to be used later
#source("C:/Users/JLi5/Desktop/Tools/Functions to be used later.R")
#read and clean data
################################################################################################
#read data NGDP_R
excel_sheets("Data/NGDP_R.xlsx")
prompt=c("You are a bank following the press conferences of the ECB
Governing Council, where the decisions about the monetary policy stance is communicated
to the public, together with an assessment of the state of the economy that motivates
the decision and a Q&A with journalists.
You follow the conference to buy/sell Overnight
Index Swap rates at different prices to manage your exposure to
interest rate fluctuations.
From the conference you infer certain developments for key interest rates
over the course of the short (3 months-1 year), medium (2-5 years) and long-term (10 years)
horizon and you buy/sell OIS instruments based on that.
We are in [date].
Using as input only these words and the information available to you as of [date],
how confused are you on the interest rate developments?
Provide separate numerical scores from 0-100 for confusion regarding
the short horizon, medium horizon and long-term horizon.
Do not incorporate any data that was not available to you as of [] in your assessment.
Please, provide your assessment in a table form.
The first three columns will be a sequence of numerical values idicating your confusion on the three
distinct horizon: confusion_s, confusion_m, confusion_l
Then, three columns with a text of explanation, less than 30 words, for your assessment, on the three
distinct horizons: explanation_s,explanation_m, explanation_l
Then, three columns with a text on whether the confusion stems from the introductory statement, from the Q&A, or both equally, on
the tree distinct horizon: part_s,part_m, part_l
Finally, three columns with a different wording that could have made the message clearer, if you see potential for more
clarity: better_s,better_m,better_l")
install.packages("gemini.R")
install.packages("gemini.R")
a
####### Script to produce an uncertainty of monetary policy factor
library(padr)
library(DescTools)
library(readxl)
library(tidyverse)
library(zoo)
library(corrr)
library(stargazer)
library(Hmisc)
library(broom)
setwd("../Desktop/Projects/Uncertainty_surprises/code/")
getwd
getwd()
library(quanteda)
library(quanteda.textstats)
library(data.table)
library(readtext)
library(broom)
library(httr2)
setAPI("AIzaSyA1O-J8XK-Y5Ymr341izyQvsDlb2UkETp4")
# Load necessary libraries and set parameters: -----
# Create custom function to send request to Gemini API with higher timeout time:
new_gemini <- function(prompt, model = "2.0-flash", temperature = 1, maxOutputTokens = 8192,
topK = 40, topP = 0.95, seed = 1234) {
model_query <- paste0("gemini-", model, ":generateContent")
url <- paste0("https://generativelanguage.googleapis.com/v1beta/models/", model_query)
api_key <- Sys.getenv("GEMINI_API_KEY")
sb <- cli_status("Gemini is answering...")
# Create generation config
generation_config <- list(
temperature = temperature,
maxOutputTokens = maxOutputTokens,
topP = topP,
topK = topK,
seed = seed
)
# Add responseModalities only for image generation model
if (model == "2.0-flash-exp-image-generation") {
generation_config$responseModalities <- list("Text", "Image")
}
# Create request body as a separate list
request_body <- list(
contents = list(
parts = list(
list(text = prompt)
)
),
generationConfig = generation_config
)
req <- request(url) |>
req_url_query(key = api_key) |>
req_headers("Content-Type" = "application/json") |>
req_body_json(request_body) |>
req_timeout(120)  # Increase the timeout here (in seconds)
resp <- req_perform(req)
# Check the status code of the response
if (resp$status_code != 200) {
cli_status_clear(id = sb)
cli_alert_danger(paste0("Error in generate request: Status code ", resp$status_code))
return(NULL)
}
cli_status_clear(id = sb)
candidates <- resp_body_json(resp)$candidates
outputs <- unlist(lapply(candidates, function(candidate) candidate$content$parts))
return(outputs)
}
# Libraries and API key:
library(gemini.R)
library(cli)
library(httr2)
setAPI("AIzaSyA1O-J8XK-Y5Ymr341izyQvsDlb2UkETp4")
# Write a prompt for LLM request: -----
prompt=c("
Context: You are a bank following the press conferences of the ECB Governing Council.
These conferences communicate decisions about the monetary policy stance, provide an assessment of the state of the economy, and include a Q&A session with journalists.
We are in [date].
Task: manage your exposure to interest rate fluctuations by buying/selling Overnight Index Swap (OIS) rates based on the information from these conferences.
Using only the words from the conference and the information available as of [date], assess your confusion about the expected interest rate developments.
**Confusion Definition**: Confusion is defined as the lack of clarity or certainty about the expected developments in interest rates.
**Score Levels**:
- **0**: No confusion. The information is clear, comprehensive, and leaves no room for doubt.
- **1-2**: Minimal confusion. The information is mostly clear, with only minor ambiguities.
- **3-4**: Low confusion. The information is generally clear, but there are some areas of uncertainty.
- **5-6**: Moderate confusion. The information is mixed, with significant ambiguities and uncertainties.
- **7-8**: High confusion. The information is unclear, with many ambiguities and conflicting signals.
- **9-10**: Maximum confusion. The information is very unclear, with pervasive ambiguities and no clear guidance.
**Criteria for Evaluation**:
- **Clarity of Communication**: How clearly are the interest rate developments communicated?
- **Consistency of Information**: Are there any conflicting statements or signals?
- **Detail and Specificity**: How detailed and specific is the information provided?
- **Context and Background**: Is there sufficient context and background information to understand the developments?
**Examples**:
- **Score 0**: The introductory statement and Q&A provide clear, detailed, and consistent information about the expected interest rate developments, with no conflicting signals.
- **Score 5**: The introductory statement is somewhat clear, but the Q&A introduces conflicting signals and ambiguities, leading to moderate confusion.
- **Score 10**: Both the introductory statement and Q&A are vague, with many conflicting signals and no clear guidance, leading to maximum confusion.
**Consistency Checks**:
- **Review Process**: Implement a review process where multiple analysts independently score the same conference and then compare scores to ensure consistency.
- **Feedback Loop**: Establish a feedback loop where analysts can discuss and resolve discrepancies in their scores.
- **Historical Context**: Review previous press conferences to identify trends.
Output: for each horizon (short-term: 3 months-1 year, medium-term: 2-5 years, long-term: 10 years), provide the following:
1. A confusion score from 0 to 10 (0 = no confusion, 10 = maximum confusion - float).
2. The reason for your chosen value in a short paragraph making reference to the evaluation criteria.
3. The main source of confusion in the confusion score (introductory statement, Q&A, or both).
4. A rephrased version of the introductory statement and Q&A answers to reduce confusion. Keep the format of the original.
5. A confusion score for the rephrased version (point 4).
Output the results in a table with three columns per task (one per horizon).
The table should have dimensions 1x12 (number of conferences; 4 tasks * 3 horizons).
Do not incorporate any data that was not available as of [date] in your assessment.
Provide only the table as output, not any text.
")
# Create a list of press conferences with dates and names: ----
dates_ecb_presconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
str_remove("\\.txt") %>%
str_extract("\\d{4}-\\d{2}-\\d{2}")
names_ecb_presconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
str_remove("\\.txt")
ecb_pressconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
paste0("../intermediate_data/texts/",.) %>%
map(~ readtext(.x)) %>%
map(~ .$text) %>%
set_names(names_ecb_presconf)
result
batch_size <- 5  # Number of press conferences per request
batches <- split(names(ecb_pressconf), ceiling(seq_along(ecb_pressconf) / batch_size))
batches
seq_along(ecb_pressconf)
ceiling(seq_along(ecb_pressconf) / batch_size)
batches <- split(names(ecb_pressconf), ceiling(seq_along(ecb_pressconf) / batch_size))
batch_size <- 5  # Number of press conferences per request
batches <- split(names(ecb_pressconf), ceiling(seq_along(ecb_pressconf) / batch_size))
concatenate_press_conferences <- function(batch_texts, batch_dates, prompt) {
batch_prompt <- map2(batch_dates, batch_texts, ~ gsub("\\[date\\]", .x, prompt)) %>%
paste(collapse = "\n\n---\n\n")  # Separate each press conference with "---"
return(batch_prompt)
}
batched_prompts <- map2(batches, names(batches), ~ {
batch_dates <- dates_ecb_presconf[.x]
batch_texts <- ecb_pressconf[.x]
concatenate_press_conferences(batch_texts, batch_dates, prompt)
})
batched_prompts
prompt
ecb_pressconf
ecb_pressconf[5]
batches <- split(texts, ceiling(seq_along(texts)/10))
batches <- split(ecb_pressconf, ceiling(seq_along(ecb_pressconf)/10))
prompt <- "Your task instructions go here"
formatted_batches <- lapply(batches, function(chunk) {
list(prompt = prompt, texts = chunk)
})
formatted_batches
batches
