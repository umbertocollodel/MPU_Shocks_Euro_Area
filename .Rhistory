#detach packages
detachAllPackages <- function() {
basic.packages.blank <-  c("stats",
"graphics",
"grDevices",
"utils",
"datasets",
"methods",
"base")
basic.packages <- paste("package:", basic.packages.blank, sep = "")
package.list <- search()[ifelse(unlist(gregexpr("package:", search())) == 1,
TRUE,
FALSE)]
package.list <- setdiff(package.list, basic.packages)
if (length(package.list) > 0)  for (package in package.list) {
detach(package, character.only = TRUE)
print(paste("package ", package, " detached", sep = ""))
}
}
detachAllPackages()
#automatically download required packages
check.packages <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg)) {
sapply(new.pkg, install.packages, dependencies = T)
}
sapply(pkg, require, character.only = T)
}
#enter package names
package <- c("relaimpo", "readxl", "tidyverse", "haven", "lubridate", "rJava", "countrycode", "xlsx", "devtools", "shapley")
#load packages (if not installed, they're installed first and then loaded into the environment)
check.packages(package)
#download shapley value decomposition package
#devtools::install_github("elbersb/shapley")
#housekeeping
rm(list = ls())
#set working directory
path <- getwd()
setwd(path)
#some functions to be used later
#source("C:/Users/JLi5/Desktop/Tools/Functions to be used later.R")
#read and clean data
################################################################################################
#read data NGDP_R
excel_sheets("Data/NGDP_R.xlsx")
setwd("../Desktop/Projects/Uncertainty_surprises/code/")
setwd("../Desktop/Projects/Uncertainty_surprises/")
setwd("../Desktop/Projects/Uncertainty_surprises/")
read.csv("../raw_data/mpu_bauer.csv")
read.csv("../raw_data/mpu_bauer.csv",sheet = 2)
read.csv("../raw_data/mpu_bauer.csv")
read.csv
read.csv("../raw_data/mpu_bauer.csv")
read.csv("../raw_data/mpu_bauer.csv") %>%
as_tibble()
library(tidyverse)
read.csv("../raw_data/mpu_bauer.csv") %>%
as_tibble()
# Load necessary libraries and set parameters: -----
library(gemini.R)
setAPI("AIzaSyA1O-J8XK-Y5Ymr341izyQvsDlb2UkETp4")
# Write a prompt for LLM: -----
prompt=c("
Context: You are a bank following the press conferences of the ECB Governing Council.
These conferences communicate decisions about the monetary policy stance, provide an assessment of the state of the economy, and include a Q&A session with journalists.
We are in [date].
Task: manage your exposure to interest rate fluctuations by buying/selling Overnight Index Swap (OIS) rates based on the information from these conferences.
Using only the words from the conference and the information available as of [date], assess your confusion about the expected interest rate developments.
**Confusion Definition**: Confusion is defined as the lack of clarity or certainty about the expected developments in interest rates.
**Score Levels**:
- **0**: No confusion. The information is clear, comprehensive, and leaves no room for doubt.
- **1-2**: Minimal confusion. The information is mostly clear, with only minor ambiguities.
- **3-4**: Low confusion. The information is generally clear, but there are some areas of uncertainty.
- **5-6**: Moderate confusion. The information is mixed, with significant ambiguities and uncertainties.
- **7-8**: High confusion. The information is unclear, with many ambiguities and conflicting signals.
- **9-10**: Maximum confusion. The information is very unclear, with pervasive ambiguities and no clear guidance.
**Criteria for Evaluation**:
- **Clarity of Communication**: How clearly are the interest rate developments communicated?
- **Consistency of Information**: Are there any conflicting statements or signals?
- **Detail and Specificity**: How detailed and specific is the information provided?
- **Context and Background**: Is there sufficient context and background information to understand the developments?
**Examples**:
- **Score 0**: The introductory statement and Q&A provide clear, detailed, and consistent information about the expected interest rate developments, with no conflicting signals.
- **Score 5**: The introductory statement is somewhat clear, but the Q&A introduces conflicting signals and ambiguities, leading to moderate confusion.
- **Score 10**: Both the introductory statement and Q&A are vague, with many conflicting signals and no clear guidance, leading to maximum confusion.
**Consistency Checks**:
- **Review Process**: Implement a review process where multiple analysts independently score the same conference and then compare scores to ensure consistency.
- **Feedback Loop**: Establish a feedback loop where analysts can discuss and resolve discrepancies in their scores.
- **Historical Context**: Review previous press conferences to identify trends.
Output: for each horizon (short-term: 3 months-1 year, medium-term: 2-5 years, long-term: 10 years), provide the following:
1. A confusion score from 0 to 10 (0 = no confusion, 10 = maximum confusion - float).
2. The reason for your chosen value.
3. The main source of confusion (introductory statement, Q&A, or both).
4. A rephrased version of the introductory statement and Q&A answers to reduce confusion.
Output the results in a table with three columns per task (one per horizon).
The table should have dimensions 1x12 (number of conferences; 4 tasks * 3 horizons).
Do not incorporate any data that was not available as of [date] in your assessment.
Provide only the table as output, not any text.
")
# Run LLM -----
# Create list with all press conferences:
dates_ecb_presconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
str_remove("\\.txt") %>%
str_extract("\\d{4}-\\d{2}-\\d{2}")
library(tidyverse)
# Initialize counters
request_count <- 0
start_time <- Sys.time()
# Function to make requests with delay and tracking
make_request <- function(text, prompt, seed = 120) {
Sys.sleep(5)  # Wait for 5 seconds between requests
request_count <<- request_count + 1
gemini(text, seed = seed, temperature = 0.5)
}
# Run Gemini LLM:
result <- ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x))
dates_ecb_presconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
str_remove("\\.txt") %>%
str_extract("\\d{4}-\\d{2}-\\d{2}")
names_ecb_presconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
str_remove("\\.txt")
ecb_pressconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
paste0("../intermediate_data/texts/",.) %>%
map(~ readtext(.x)) %>%
map(~ .$text) %>%
set_names(names_ecb_presconf)
library(readtext)
dates_ecb_presconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
str_remove("\\.txt") %>%
str_extract("\\d{4}-\\d{2}-\\d{2}")
names_ecb_presconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
str_remove("\\.txt")
ecb_pressconf=list.files("../intermediate_data/texts/") %>%
str_subset("\\d") %>%
paste0("../intermediate_data/texts/",.) %>%
map(~ readtext(.x)) %>%
map(~ .$text) %>%
set_names(names_ecb_presconf)
# Initialize counters
request_count <- 0
start_time <- Sys.time()
# Function to make requests with delay and tracking
make_request <- function(text, prompt, seed = 120) {
Sys.sleep(5)  # Wait for 5 seconds between requests
request_count <<- request_count + 1
gemini(text, seed = seed, temperature = 0.5)
}
# Run Gemini LLM:
result <- ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x))
result[[1]]
# Initialize counters
request_count <- 0
start_time <- Sys.time()
# Function to make requests with delay and tracking
make_request <- function(text, prompt, seed = 120) {
Sys.sleep(5)  # Wait for 5 seconds between requests
request_count <<- request_count + 1
gemini(text, seed = seed, temperature = 0.5)
}
# Run Gemini LLM:
result <- ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
rlang::last_trace()
result <- ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
gemini("what is a cat?")
ecb_pressconf[[3]]
library(httr)
# Initialize counters
request_count <- 0
start_time <- Sys.time()
# Set a global timeout of 60 seconds
set_config(config(timeout(60)))
library(httr)
# Initialize counters
request_count <- 0
start_time <- Sys.time()
# Set a global timeout of 60 seconds
set_config(config(timeout(100)))
# Initialize counters
request_count <- 0
start_time <- Sys.time()
# Function to make requests with delay and tracking
make_request <- function(text, prompt, seed = 120) {
Sys.sleep(5)  # Wait for 5 seconds between requests
request_count <<- request_count + 1
gemini(text, seed = seed, temperature = 0.5)
}
# Run Gemini LLM:
result <- ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
install.packages("curl")
library(curl)
install.packages("curl")
httr::request
gemini
# Load necessary libraries and set parameters: -----
new_gemini <- function(prompt, model = "2.0-flash", temperature = 1, maxOutputTokens = 8192,
topK = 40, topP = 0.95, seed = 1234, timeout = 60) {
# Validate all parameters at once
if (!validate_params(prompt, model, temperature, topP, topK, seed, api_key = TRUE)) {
return(NULL)
}
model_query <- paste0("gemini-", model, ":generateContent")
url <- paste0("https://generativelanguage.googleapis.com/v1beta/models/", model_query)
api_key <- Sys.getenv("GEMINI_API_KEY")
sb <- cli_status("Gemini is answering...")
# Create generation config
generation_config <- list(
temperature = temperature,
maxOutputTokens = maxOutputTokens,
topP = topP,
topK = topK,
seed = seed
)
# Add responseModalities only for image generation model
if (model == "2.0-flash-exp-image-generation") {
generation_config$responseModalities <- list("Text", "Image")
}
# Create request body as a separate list
request_body <- list(
contents = list(
parts = list(
list(text = prompt)
)
),
generationConfig = generation_config
)
req <- request(url) |>
req_url_query(key = api_key) |>
req_headers("Content-Type" = "application/json") |>
req_body_json(request_body) |>
req_timeout(timeout)  # Increase the timeout here (in seconds)
resp <- req_perform(req)
# Check the status code of the response
if (resp$status_code != 200) {
cli_status_clear(id = sb)
cli_alert_danger(paste0("Error in generate request: Status code ", resp$status_code))
return(NULL)
}
cli_status_clear(id = sb)
candidates <- resp_body_json(resp)$candidates
outputs <- unlist(lapply(candidates, function(candidate) candidate$content$parts))
return(outputs)
}
new_gemini
# Function to make requests with delay and tracking
make_request <- function(text, prompt, seed = 120) {
Sys.sleep(5)  # Wait for 5 seconds between requests
request_count <<- request_count + 1
new_gemini(text, seed = seed, temperature = 0.5)
}
ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
# Load necessary libraries and set parameters: -----
new_gemini <- function(prompt, model = "2.0-flash", temperature = 1, maxOutputTokens = 8192,
topK = 40, topP = 0.95, seed = 1234) {
model_query <- paste0("gemini-", model, ":generateContent")
url <- paste0("https://generativelanguage.googleapis.com/v1beta/models/", model_query)
api_key <- Sys.getenv("GEMINI_API_KEY")
sb <- cli_status("Gemini is answering...")
# Create generation config
generation_config <- list(
temperature = temperature,
maxOutputTokens = maxOutputTokens,
topP = topP,
topK = topK,
seed = seed
)
# Add responseModalities only for image generation model
if (model == "2.0-flash-exp-image-generation") {
generation_config$responseModalities <- list("Text", "Image")
}
# Create request body as a separate list
request_body <- list(
contents = list(
parts = list(
list(text = prompt)
)
),
generationConfig = generation_config
)
req <- request(url) |>
req_url_query(key = api_key) |>
req_headers("Content-Type" = "application/json") |>
req_body_json(request_body) |>
req_timeout(timeout)  # Increase the timeout here (in seconds)
resp <- req_perform(req)
# Check the status code of the response
if (resp$status_code != 200) {
cli_status_clear(id = sb)
cli_alert_danger(paste0("Error in generate request: Status code ", resp$status_code))
return(NULL)
}
cli_status_clear(id = sb)
candidates <- resp_body_json(resp)$candidates
outputs <- unlist(lapply(candidates, function(candidate) candidate$content$parts))
return(outputs)
}
ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
library(cli)
ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
library(httr2)
ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
# Load necessary libraries and set parameters: -----
new_gemini <- function(prompt, model = "2.0-flash", temperature = 1, maxOutputTokens = 8192,
topK = 40, topP = 0.95, seed = 1234) {
model_query <- paste0("gemini-", model, ":generateContent")
url <- paste0("https://generativelanguage.googleapis.com/v1beta/models/", model_query)
api_key <- Sys.getenv("GEMINI_API_KEY")
sb <- cli_status("Gemini is answering...")
# Create generation config
generation_config <- list(
temperature = temperature,
maxOutputTokens = maxOutputTokens,
topP = topP,
topK = topK,
seed = seed
)
# Add responseModalities only for image generation model
if (model == "2.0-flash-exp-image-generation") {
generation_config$responseModalities <- list("Text", "Image")
}
# Create request body as a separate list
request_body <- list(
contents = list(
parts = list(
list(text = prompt)
)
),
generationConfig = generation_config
)
req <- request(url) |>
req_url_query(key = api_key) |>
req_headers("Content-Type" = "application/json") |>
req_body_json(request_body) |>
req_timeout(120)  # Increase the timeout here (in seconds)
resp <- req_perform(req)
# Check the status code of the response
if (resp$status_code != 200) {
cli_status_clear(id = sb)
cli_alert_danger(paste0("Error in generate request: Status code ", resp$status_code))
return(NULL)
}
cli_status_clear(id = sb)
candidates <- resp_body_json(resp)$candidates
outputs <- unlist(lapply(candidates, function(candidate) candidate$content$parts))
return(outputs)
}
ecb_pressconf %>%
map(~ paste0(prompt, "Press Conference:", .x)) %>%
map2(dates_ecb_presconf, ~ gsub("\\[date\\]", .y, .x)) %>%
map(~ make_request(.x,
seed = 120)) %>%
set_names(names_ecb_presconfresult)
